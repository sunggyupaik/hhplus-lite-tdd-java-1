# Step1 - TDD 기본 다지기

## 개요
다수의 사용자와 트랜잭션이 동시에 동일한 데이터에 접근하는 환경이 증가하고 있습니다. 이러한 환경에서 일관성, 무결성, 정확성을 유지하기 위한 효율적인 동시성 제어 기법을 알아보겠습니다.

## 동시성 제어란?
- 동시성 제어(Concurrency Control)는 여러 쓰레드가 동시에 같은 자원에 접근할 때, 데이터의 일관성과 무결성을 유지하기 위한 기술입니다.

즉, 동시에 같은 자원을 읽거나 수정해도 결과가 순차적으로 실행한 것처럼 만드는 것이 목표입니다.

만약 동시성 제어를 하지 못하면 다음과 같은 문제가 발생합니다.

|문제|설명|예시|
|----|----|----|
|Lost Update| 같은 자원을 동시에 수정하면 마지막 변경으로 덮어써짐|2명의 사용자가 재고 10개를 동시에 1개씩 차감하여도 재고가 9개가 남음|
|Phantom Read|조건에 맞는 행의 갯수가 바뀜|범위 조회 중 다른 트랜잭션이 추가되면서 예상 결과보다 더 많은 결과가 조회됨

동시성 제어에 다양한 기술이 있으며 락 기반을 중점으로 확인해보겠습니다. 단일 인스턴스 기준으로 자원에 동시에 접근을 차단하고자 락을 거는 비관적 락(Lock 기반 제어), 자원에 동시 접근은 허용하지만 원자성을 보장하는 낙관적 락을 알아보겠습니다. 

멀티 인스턴스 환경에서는 Redis 분산 락, Saga 패턴 등을 사용하여 데이터의 일관성을 유지할 수 있습니다.

## 동시성 제어의 주요 방식

### Lock 기반 제어
---
- 개념: 자원에 접근하기 전에 잠금을 설정하여 다른 쓰레드의 접근을 제한합니다.
- 종류:
  - 공유 락 (Shared Lock) : 다른 쓰레드의 공유락 가능, 배타 락은 불가능
  - 배타 락 (Exclusive Lock) : 다른 쓰레드의 공유 락, 배타 락 모두 불가능(단, 공유 락 조회가 아닌 일반 조회는 락이 걸리지 않고 조회 가능)  

장점
 - 일관성 보장 및 직렬실행과 동일한 결과 확보

단점
  - 대기, 교착상태 발생 가능하며 락 경합 시 성능 저하

### 낙관적 제어
---
- 개념: 충돌이 적게 발생할 것을 예상하고 트랜잭션 종료 시에 충돌을 감지합니다.
- 구현방법: 각 데이터에 버전(version)이나 타임스탬프를 할당하고 커밋 시점에서 변경 대상의 버전이 일치하는지 확인합니다.

장점
  - 락이 없는 논블로킹(Non-blocking) 으로 충돌이 적은 경우 성능이 우수

단점
  - 충돌 발생 시 재시도 비용이 발생하며 변경 빈도가 높은 경우 부적합


## Lock 기반 제어 종류

### synchronized
- JVM 수준의 모니터 락(Monitor Lock)을 사용합니다
- 코드 블록에 진입하면 자동으로 락을 획득, 종료 시 해제됩니다.
- 예외가 발생해도 락은 자동으로 해제되어 안전합니다.
```java
public synchronized void increase() {
  count++;
}
```

### ReentrantLock
- Java 5부터 추가된 명시적 락 객체 기반
- 예외가 발생해도 `unlock()` 호출을 직접 명시 필요(finally 블록 필수)
- 타임아웃, 인터럽트, Condition 설정 등으로 더 세밀한 적용 가능
- 공정성(Fair) 옵션으로 설정 가능
```java
private final ReentrantLock lock = new ReentrantLock();

public void increase() {
  lock.lock();
  try {
    count++;
  } finally {
    lock.unlock(0;)
  }
}
```
  
- Map을 활용하여 사용자마다 락을 설정 가능
```java
private final Map<Long, ReentrantLock> lockTable = new HashMap<>();
```

## 결론
- Lock 기반 제어는 데이터의 정확성이 절대적인 경우에 적합합니다.
- 낙관적 제어는 충돌 빈도가 낮은 곳에서 성능이 좋습니다.
- `synchronized`보다 `ReentrantLock`이 더 상세한 설정이 가능하여 좋습니다.
- 멀티 인스턴스에서는 분산 락, Saga 패턴 등으로 트랜잭션 일관성을 유지할 수 있습니다.